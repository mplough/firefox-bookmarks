"""Extract links from an HTML bookmarks file exported from Firefox.

A Firefox bookmarks file doesn't make bookmarks available in a form that's easy to work with.
This tool solves that problem.

LIMITATIONS
You can have two folders with the same name in the same folder.
These will get condensed down to one folder.
"""

import json
import sys

from bs4 import BeautifulSoup
import click


def firefox_link(address, name, attrs):
    return {
        'address': address,
        'name': name,
        'attrs': attrs
    }


def bookmark_folder(folder_name, bookmarks):
    return {
        'folder_name': folder_name,
        'bookmarks': bookmarks
    }


def parse_links(root):
    """Generate all links in an HTML bookmark file exported from Firefox.

    The doctype of this file claims to be "NETSCAPE-Bookmark-file-1".
    """
    bookmarks = []
    for e in root.find_all('dt', recursive=False):
        for link in e.find_all('a', recursive=False):
            if link.get('href').startswith('place:'):
                # Skip recents and other autogenerated bookmark lists
                continue
            bookmarks.append(firefox_link(
                link.get('href'),
                link.string,
                {attr: link.get(attr) for attr in link.attrs if attr != 'href'},
            ))

        for folder in e.find_all('h3', recursive=False):
            folder_name = folder.string
            folder_dl = folder.find_next_sibling('dl')
            bookmarks.append(bookmark_folder(
                folder_name,
                parse_links(folder_dl)
            ))
    return bookmarks


def parse_links_from_file(filename):
    with open(filename) as f:
        soup = BeautifulSoup(f, 'html5lib')
    return parse_links(soup.find('dl'))


def bookmark_addresses(bookmarks):
    # A bookmark is either a firefox_link or a bookmark_folder
    for bookmark in bookmarks:
        if 'address' in bookmark:
            yield bookmark['address']
        elif 'bookmarks' in bookmark:
            yield from bookmark_addresses(bookmark['bookmarks'])


def remove_duplicate_bookmarks(bookmarks, addresses):
    """Remove addresses from a tree of bookmarks."""
    out_bookmarks = []
    for bookmark in bookmarks:
        if 'address' in bookmark:
            if bookmark['address'] in addresses:
                print(f'Dupe: {bookmark["address"]}', file=sys.stderr)
            else:
                out_bookmarks.append(bookmark)
        elif 'bookmarks' in bookmark:
            deduped = remove_duplicate_bookmarks(bookmark['bookmarks'], addresses)
            if deduped:
                out_bookmarks.append(bookmark_folder(bookmark['folder_name'], deduped))
    return out_bookmarks


@click.group(help=__doc__)
def cli():
    pass


@cli.command('extract')
@click.argument('bookmarks_filename')
def click_extract(bookmarks_filename):
    """Extract bookmarks in a bookmarks HTML file to structured JSON."""
    print(json.dumps(parse_links_from_file(bookmarks_filename), indent=4))


@cli.command('merge')
@click.argument('primary_bookmarks_filename')
@click.argument('secondary_bookmarks_filename')
def click_merge(primary_bookmarks_filename, secondary_bookmarks_filename):
    """Merge bookmarks.

    All bookmarks from the primary bookmarks file are kept.

    The bookmark folder structure from the secondary file is preserved in a new folder with the
    following deduplication operations performed:

    - If a bookmark's address also appears in the primary file, it is omitted from the secondary.
    - If omissions of bookmarks result in empty folders, the empty folders are pruned.

    A new bookmarks file is written out, which can then be used to restore / overwrite Firefox's
    bookmarks in the Bookmarks Manager.  The user can then use the Bookmarks Manager to manipulate
    the secondary's folder structure, merging it with the primary with the assurance that doing so
    won't result in adding duplicate bookmarks.
    """
    primary_bookmarks = parse_links_from_file(primary_bookmarks_filename)
    primary_addresses = set(bookmark_addresses(primary_bookmarks))

    secondary_bookmarks = parse_links_from_file(secondary_bookmarks_filename)

    deduplicated_secondary_bookmarks = remove_duplicate_bookmarks(
        secondary_bookmarks, primary_addresses)

    merged_bookmarks = primary_bookmarks + deduplicated_secondary_bookmarks
    print(json.dumps(merged_bookmarks, indent=4))

    # TODO write out the HTML file...hello jinja2?


if __name__ == '__main__':
    cli()
